
parent :: Person * Person
dad :: Person * Man

CLASSIFY Man IS Man /\ Person
CLASSIFY Woman IS Woman /\ Person

"Start"         ∋ Fresh 0  ↦ Fresh 5
"Statement"     ∋ Fresh 0  ↦ Fresh 1
"declaration"   ∋ Fresh 1  ↦ Fresh 2
"concepts"      ∋ Fresh 2  ↦ Fresh 4
"relation"      ∋ Fresh 2  ↦ Fresh 3
"origin"        ∋ Fresh 3  ↦ Position 1 0
"string"        ∋ Fresh 3  ↦ "parent"
"fst"           ∋ Fresh 4  ↦ "Person"
"snd"           ∋ Fresh 4  ↦ "Person"
"Start"         ∋ Fresh 5  ↦ Fresh 10
"Statement"     ∋ Fresh 5  ↦ Fresh 6
"declaration"   ∋ Fresh 6  ↦ Fresh 7
"concepts"      ∋ Fresh 7  ↦ Fresh 9
"relation"      ∋ Fresh 7  ↦ Fresh 8
"origin"        ∋ Fresh 8  ↦ Position 2 0
"string"        ∋ Fresh 8  ↦ "dad"
"fst"           ∋ Fresh 9  ↦ "Person"
"snd"           ∋ Fresh 9  ↦ "Man"
"Start"         ∋ Fresh 10 ↦ Fresh 15
"Statement"     ∋ Fresh 10 ↦ Fresh 11
"classification"∋ Fresh 11 ↦ Fresh 12
"conceptList"   ∋ Fresh 12 ↦ Fresh 13
"mainConcept"   ∋ Fresh 12 ↦ "Man"
"head1"         ∋ Fresh 13 ↦ "Man"
"tail1"         ∋ Fresh 13 ↦ Fresh 14
"head1"         ∋ Fresh 14 ↦ "Person"
"Start"         ∋ Fresh 15 ↦ Fresh 20
"Statement"     ∋ Fresh 15 ↦ Fresh 16
"classification"∋ Fresh 16 ↦ Fresh 17
"conceptList"   ∋ Fresh 17 ↦ Fresh 18
"mainConcept"   ∋ Fresh 17 ↦ "Woman"
"head1"         ∋ Fresh 18 ↦ "Woman"
"tail1"         ∋ Fresh 18 ↦ Fresh 19
"head1"         ∋ Fresh 19 ↦ "Person"


parent :: Person * Person
dad :: Person * Man
name :: Person * String -- string is built-in (has a parser defined for it)

CLASSIFY Man IS Man /\ Person
CLASSIFY Woman IS Woman /\ Person

VIEW Man = ["Man", name]
VIEW Woman = ["Woman", name]
VIEW Person = ["Father", "of", name, "is", dad]

CLASSIFY Person IS Statement /\ Person -- Parser will parse a list of statements

Man := "Man", "name" "String"
Person := "Man", "name" "String"
        | "Woman", "name" "String"
        | "Father", "of", "name" "String", "is", "dad" "Man"
Start := "Statement" "Statement", "Start" "Start"
       | 
Statement := "Man", "name" "String"
           | "Woman", "name" "String"
           | "Father", "of", "name" "String", "is", "dad" "Man"
Woman := "Woman", "name" "String"

"choice"      ∋ "Man"           ↦ Fresh 27
"continuation"∋ "NextStatement" ↦ "gotoStart"
"recogniser"  ∋ "NextStatement" ↦ "Statement"
"choice"      ∋ "Person"        ↦ Fresh 27
"choice"      ∋ "Person"        ↦ Fresh 34
"choice"      ∋ "Person"        ↦ Fresh 41
"choice"      ∋ "Start"         ↦ "NextStatement"
"choice"      ∋ "Start"         ↦ "endOfFile"
"nonTerminal" ∋ "Start"         ↦ "Start"
"choice"      ∋ "Statement"     ↦ Fresh 27
"choice"      ∋ "Statement"     ↦ Fresh 34
"choice"      ∋ "Statement"     ↦ Fresh 41
"nonTerminal" ∋ "Statement"     ↦ "Statement"
"choice"      ∋ "Woman"         ↦ Fresh 34
"nonTerminal" ∋ "dad"           ↦ "Man"
"rule"        ∋ "dad"           ↦ Fresh 7
"recogniser"  ∋ "gotoStart"     ↦ "Start"
"eFst"        ∋ "keepOrigin"    ↦ Fresh 59
"eSnd"        ∋ "keepOrigin"    ↦ Fresh 58
"rule"        ∋ "keepOrigin"    ↦ "keepOrigin"
"eFst"        ∋ "keepString"    ↦ Fresh 61
"eSnd"        ∋ "keepString"    ↦ Fresh 60
"rule"        ∋ "keepString"    ↦ "keepString"
"nonTerminal" ∋ "name"          ↦ "String"
"rule"        ∋ "name"          ↦ Fresh 12
"nonTerminal" ∋ "parent"        ↦ "Person"
"rule"        ∋ "parent"        ↦ Fresh 2
"eFst"        ∋ Fresh 2         ↦ Fresh 62
"eSnd"        ∋ Fresh 2         ↦ Fresh 63
"eFst"        ∋ Fresh 7         ↦ Fresh 64
"eSnd"        ∋ Fresh 7         ↦ Fresh 65
"eFst"        ∋ Fresh 12        ↦ Fresh 66
"eSnd"        ∋ Fresh 12        ↦ Fresh 67
"continuation"∋ Fresh 27        ↦ Fresh 30
"recogniser"  ∋ Fresh 27        ↦ "\"Man\""
"recogniser"  ∋ Fresh 30        ↦ "name"
"continuation"∋ Fresh 34        ↦ Fresh 37
"recogniser"  ∋ Fresh 34        ↦ "\"Woman\""
"recogniser"  ∋ Fresh 37        ↦ "name"
"continuation"∋ Fresh 41        ↦ Fresh 44
"recogniser"  ∋ Fresh 41        ↦ "\"Father\""
"continuation"∋ Fresh 44        ↦ Fresh 46
"recogniser"  ∋ Fresh 44        ↦ "\"of\""
"continuation"∋ Fresh 46        ↦ Fresh 48
"recogniser"  ∋ Fresh 46        ↦ "name"
"continuation"∋ Fresh 48        ↦ Fresh 50
"recogniser"  ∋ Fresh 48        ↦ "\"is\""
"recogniser"  ∋ Fresh 50        ↦ "dad"
"post"        ∋ Fresh 58        ↦ "origin"
"pre"         ∋ Fresh 59        ↦ "origin"
"post"        ∋ Fresh 60        ↦ "string"
"pre"         ∋ Fresh 61        ↦ "string"
"pre"         ∋ Fresh 62        ↦ "parent"
"post"        ∋ Fresh 63        ↦ "parent"
"pre"         ∋ Fresh 64        ↦ "dad"
"post"        ∋ Fresh 65        ↦ "dad"
"pre"         ∋ Fresh 66        ↦ "name"
"post"        ∋ Fresh 67        ↦ "name"


Man Han
Father of Bas is Man Stef

"name"∋ Fresh 1 ↦ "Han"
"dad" ∋ Fresh 3 ↦ Fresh 4
"name"∋ Fresh 3 ↦ "Bas"
"name"∋ Fresh 4 ↦ "Stef"


parent :: Person * Person
dad :: Person * Man
name :: Person * String -- string is built-in (has a parser defined for it)

CLASSIFY Man IS Man /\ Person
CLASSIFY Woman IS Woman /\ Person

VIEW Man = ["Man", name]
VIEW Woman = ["Woman", name]
VIEW Person = ["Father", "of", name, "is", dad]

CLASSIFY Person IS Statement /\ Person -- Parser will parse a list of statements

     1	parent :: Person * Person
     2	dad :: Person * Man
     3	name :: Person * String -- string is built-in (has a parser defined for it)
     4	
     5	CLASSIFY Man IS Man /\ Person
     6	CLASSIFY Woman IS Woman /\ Person
     7	
     8	VIEW Man = ["Man", name]
     9	VIEW Woman = ["Woman", name]
    10	VIEW Person = ["Father", "of", name, "is", dad]
    11	
    12	CLASSIFY Person IS Statement /\ Person -- Parser will parse a list of statements
    13	
    14	RULE dad |- parent
375
195
195
Man := "Man", "name" "String"
Person := "Man", "name" "String"
        | "Woman", "name" "String"
        | "Father", "of", "name" "String", "is", "dad" "Man"
Start := "Statement" "Statement", "Start" "Start"
       | 
Statement := "Man", "name" "String"
           | "Woman", "name" "String"
           | "Father", "of", "name" "String", "is", "dad" "Man"
Woman := "Woman", "name" "String"

Man := "Man", "name" "String"
Person := "Man", "name" "String"
        | "Woman", "name" "String"
        | "Father", "of", "name" "String", "is", "dad" "Man"
Start := "Statement" "Statement", "Start" "Start"
       | 
Statement := "Man", "name" "String"
           | "Woman", "name" "String"
           | "Father", "of", "name" "String", "is", "dad" "Man"
Woman := "Woman", "name" "String"


Man Han
Father of Bas is Man Stef

"name"  ∋ Fresh 1 ↦ "Han"
"dad"   ∋ Fresh 3 ↦ Fresh 4
"name"  ∋ Fresh 3 ↦ "Bas"
"parent"∋ Fresh 3 ↦ Fresh 4
"name"  ∋ Fresh 4 ↦ "Stef"


Man Bas
Father of Bas is Man Stef

"name"  ∋ Fresh 1 ↦ "Bas"
"dad"   ∋ Fresh 3 ↦ Fresh 4
"name"  ∋ Fresh 3 ↦ "Bas"
"parent"∋ Fresh 3 ↦ Fresh 4
"name"  ∋ Fresh 4 ↦ "Stef"

parent :: Person * Person
dad :: Person * Man
name :: Person * String -- string is built-in (has a parser defined for it)

CLASSIFY Man IS Man /\ Person
CLASSIFY Woman IS Woman /\ Person

VIEW Man = ["Man", name]
VIEW Woman = ["Woman", name]
VIEW Person = ["Father", "of", name, "is", dad]

CLASSIFY Person IS Statement /\ Person -- Parser will parse a list of statements

RULE pre dad |- post parent
 -- names identify the person (name is INJ)
RULE (pre name;pre name ~) |- I -- symbol for identity relation is . for now

RULE pre name |- I
"dad"   ∋ "Bas"  ↦ "Stef"
"name"  ∋ "Bas"  ↦ "Bas"
"parent"∋ "Bas"  ↦ "Stef"
"name"  ∋ "Stef" ↦ "Stef"

